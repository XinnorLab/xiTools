#!/usr/bin/env python3
import argparse
import json
import os
import subprocess
import sys
import fnmatch
import re
import curses
from typing import List, Dict, Any


def human_size(num_bytes: int, si: bool = False) -> str:
    if num_bytes is None:
        return 'N/A'
    base = 1000 if si else 1024
    if num_bytes < base:
        return f"{num_bytes} B"
    units = ["B", "KB", "MB", "GB", "TB", "PB", "EB"] if si else ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB"]
    for i, unit in enumerate(units[1:], 1):
        threshold = base ** i
        next_threshold = base ** (i + 1)
        if num_bytes < next_threshold or i + 1 == len(units):
            value = num_bytes / threshold
            return f"{value:.1f} {unit}"
    return f"{num_bytes} B"


def parse_size(size_str: str) -> int:
    match = re.fullmatch(r"(?i)\s*(\d+(?:\.\d+)?)([kmgtpe]?i?b?)?\s*", size_str)
    if not match:
        raise ValueError(f"Invalid size: {size_str}")
    number = float(match.group(1))
    suffix = match.group(2).lower() if match.group(2) else ''
    multipliers = {
        '': 1,
        'b': 1,
        'k': 1024,
        'kb': 1000,
        'ki': 1024,
        'kib': 1024,
        'm': 1024 ** 2,
        'mb': 1000 ** 2,
        'mi': 1024 ** 2,
        'mib': 1024 ** 2,
        'g': 1024 ** 3,
        'gb': 1000 ** 3,
        'gi': 1024 ** 3,
        'gib': 1024 ** 3,
        't': 1024 ** 4,
        'tb': 1000 ** 4,
        'ti': 1024 ** 4,
        'tib': 1024 ** 4,
        'p': 1024 ** 5,
        'pb': 1000 ** 5,
        'pi': 1024 ** 5,
        'pib': 1024 ** 5,
        'e': 1024 ** 6,
        'eb': 1000 ** 6,
        'ei': 1024 ** 6,
        'eib': 1024 ** 6,
    }
    factor = multipliers.get(suffix)
    if factor is None:
        raise ValueError(f"Invalid size suffix: {suffix}")
    return int(number * factor)


def read_numa(name: str):
    paths = [
        f"/sys/block/{name}/device/numa_node",
        f"/sys/class/nvme/{name}/device/numa_node",
    ]
    for p in paths:
        try:
            with open(p) as f:
                val = int(f.read().strip())
                if val >= 0:
                    return val
        except FileNotFoundError:
            continue
        except ValueError:
            continue
    return None


def collect_devices() -> List[Dict[str, Any]]:
    try:
        out = subprocess.check_output([
            'lsblk', '-J', '-b', '-dn', '-o', 'NAME,SIZE,MODEL,SERIAL,VENDOR,TRAN'
        ])
    except (OSError, subprocess.CalledProcessError) as e:
        print(f"Error running lsblk: {e}", file=sys.stderr)
        sys.exit(2)
    data = json.loads(out.decode())
    devs = []
    for dev in data.get('blockdevices', []):
        name = dev.get('name')
        size = dev.get('size')
        try:
            size = int(size) if size is not None else 0
        except ValueError:
            size = 0
        vendor = (dev.get('vendor') or '').strip() or 'N/A'
        model = (dev.get('model') or '').strip() or 'N/A'
        serial = (dev.get('serial') or '').strip() or 'N/A'
        tran = (dev.get('tran') or '').strip() or 'unknown'
        numa = read_numa(name)
        devs.append({
            'name': f"/dev/{name}",
            'size_bytes': size,
            'vendor': vendor,
            'model': model,
            'serial': serial,
            'tran': tran,
            'numa_node': numa,
        })
    return devs


def apply_filters(devs: List[Dict[str, Any]], args) -> List[Dict[str, Any]]:
    res = []
    for d in devs:
        if args.type and d['tran'] != args.type:
            continue
        if args.name and not fnmatch.fnmatch(d['name'], args.name):
            continue
        if args.node is not None:
            if d['numa_node'] is None or d['numa_node'] != args.node:
                continue
        if args.size_min is not None and d['size_bytes'] < args.size_min:
            continue
        if args.size_max is not None and d['size_bytes'] > args.size_max:
            continue
        res.append(d)
    return res


def sort_devices(devs: List[Dict[str, Any]], args) -> None:
    if not args.sort:
        if args.reverse:
            devs.reverse()
        return
    key_funcs = {
        'name': lambda d: d['name'],
        'size': lambda d: d['size_bytes'],
        'vendor': lambda d: d['vendor'],
        'numa': lambda d: d['numa_node'] if d['numa_node'] is not None else -1,
    }
    key = key_funcs.get(args.sort)
    devs.sort(key=key, reverse=args.reverse)


def output_table(devs: List[Dict[str, Any]], si: bool):
    headers = ['NAME', 'SIZE', 'BYTES', 'VENDOR', 'MODEL', 'SERIAL', 'NUMA']
    rows = []
    for d in devs:
        rows.append([
            d['name'],
            human_size(d['size_bytes'], si),
            str(d['size_bytes']),
            d['vendor'],
            d['model'],
            d['serial'],
            str(d['numa_node']) if d['numa_node'] is not None else 'N/A'
        ])
    widths = [len(h) for h in headers]
    for row in rows:
        for i, cell in enumerate(row):
            if len(cell) > widths[i]:
                widths[i] = len(cell)
    fmt = '  '.join('{:<%d}' % w for w in widths)
    print(fmt.format(*headers))
    for row in rows:
        print(fmt.format(*row))


def output_json(devs: List[Dict[str, Any]], si: bool):
    items = []
    for d in devs:
        item = dict(d)
        item['size_human'] = human_size(d['size_bytes'], si)
        items.append(item)
    print(json.dumps(items, indent=2))


def output_yaml(devs: List[Dict[str, Any]], si: bool):
    try:
        import yaml
    except ModuleNotFoundError:
        print('YAML output requires PyYAML', file=sys.stderr)
        sys.exit(2)
    items = []
    for d in devs:
        item = dict(d)
        item['size_human'] = human_size(d['size_bytes'], si)
        items.append(item)
    print(yaml.safe_dump(items, sort_keys=False))


def output_tsv(devs: List[Dict[str, Any]], si: bool):
    headers = ['NAME', 'SIZE', 'BYTES', 'VENDOR', 'MODEL', 'SERIAL', 'NUMA']
    print('\t'.join(headers))
    for d in devs:
        print('\t'.join([
            d['name'],
            human_size(d['size_bytes'], si),
            str(d['size_bytes']),
            d['vendor'],
            d['model'],
            d['serial'],
            str(d['numa_node']) if d['numa_node'] is not None else 'N/A'
        ]))


def interactive_mode(devs: List[Dict[str, Any]], si: bool) -> List[Dict[str, Any]]:
    """Simple curses based TUI for selecting devices."""
    for idx, d in enumerate(devs):
        d['_idx'] = idx

    sort_cycle = [None, 'name', 'size', 'numa', 'vendor']
    sort_idx = 0
    reverse = False
    filter_text = ''
    selected = set()

    def safe_addnstr(win, y, x, text, n, attr=0):
        try:
            win.addnstr(y, x, text, n, attr)
        except curses.error:
            pass

    def apply_view():
        key = sort_cycle[sort_idx]
        items = [d for d in devs if filter_text.lower() in (d['name'] + ' ' + d['model']).lower()]
        if key:
            if key == 'size':
                items.sort(key=lambda d: d['size_bytes'], reverse=reverse)
            elif key == 'numa':
                items.sort(key=lambda d: d['numa_node'] if d['numa_node'] is not None else -1, reverse=reverse)
            else:
                items.sort(key=lambda d: d[key], reverse=reverse)
        elif reverse:
            items.reverse()
        return items

    def show_detail(stdscr, dev):
        h, w = stdscr.getmaxyx()
        win = curses.newwin(h - 4, w - 4, 2, 2)
        win.box()
        lines = json.dumps(dev, indent=2).splitlines()
        for i, line in enumerate(lines[:h - 6]):
            safe_addnstr(win, i + 1, 2, line, w - 6)
        safe_addnstr(win, h - 5, 2, "Press q or Esc", w - 6)
        while True:
            c = win.getch()
            if c in (27, ord('q')):
                break
        win.clear()
        stdscr.touchwin()
        stdscr.refresh()

    def show_help(stdscr):
        h, w = stdscr.getmaxyx()
        win = curses.newwin(h - 4, w - 4, 2, 2)
        win.box()
        lines = [
            "Arrow keys/PgUp/PgDn/Home/End: navigate",
            "Space: toggle selection",
            "a: toggle all in view",
            "*: select all in view",
            "/: search",
            "f: filter",
            "s: cycle sort",
            "r: reverse sort",
            "Enter: show details",
            "Ctrl-S: save and exit",
            "q or Ctrl-C: quit",
        ]
        for i, line in enumerate(lines[:h - 6]):
            safe_addnstr(win, i + 1, 2, line, w - 6)
        safe_addnstr(win, h - 5, 2, "Press any key to return", w - 6)
        win.refresh()
        win.getch()
        win.clear()
        stdscr.touchwin()
        stdscr.refresh()

    def run(stdscr):
        nonlocal sort_idx, reverse, filter_text
        curses.curs_set(0)
        stdscr.keypad(True)
        pos = 0
        top = 0
        view = apply_view()
        while True:
            max_y, max_x = stdscr.getmaxyx()
            stdscr.erase()
            header = ' Sel NAME              SIZE      VENDOR     MODEL            NUMA'
            safe_addnstr(stdscr, 0, 0, header.ljust(max_x), max_x, curses.A_REVERSE)
            visible = view[top:top + max_y - 2]
            for idx, d in enumerate(visible):
                mark = 'âœ”' if d['_idx'] in selected else ' '
                line = (
                    f" {mark} {d['name']:<16} {human_size(d['size_bytes'], si):>8} "
                    f"{d['vendor']:<10} {d['model']:<15} "
                    f"{d['numa_node'] if d['numa_node'] is not None else 'N/A'}"
                )
                attr = curses.A_REVERSE if top + idx == pos else curses.A_NORMAL
                safe_addnstr(stdscr, idx + 1, 0, line.ljust(max_x), max_x, attr)
            status = (
                f"{len(selected)}/{len(devs)} selected  sort:{sort_cycle[sort_idx] or 'none'}"
                f"{' desc' if reverse else ''} filter:{filter_text}  ? for help"
            )
            safe_addnstr(stdscr, max_y - 1, 0, status.ljust(max_x), max_x, curses.A_REVERSE)
            ch = stdscr.getch()
            if ch == curses.KEY_UP and pos > 0:
                pos -= 1
            elif ch == curses.KEY_DOWN and pos < len(view) - 1:
                pos += 1
            elif ch == curses.KEY_PPAGE:
                pos = max(0, pos - (max_y - 2))
            elif ch == curses.KEY_NPAGE:
                pos = min(len(view) - 1, pos + (max_y - 2))
            elif ch == curses.KEY_HOME:
                pos = 0
            elif ch == curses.KEY_END:
                pos = len(view) - 1
            elif ch == ord(' '):
                idx = view[pos]['_idx']
                if idx in selected:
                    selected.remove(idx)
                else:
                    selected.add(idx)
            elif ch == ord('a'):
                for d in view:
                    idx = d['_idx']
                    if idx in selected:
                        selected.remove(idx)
                    else:
                        selected.add(idx)
            elif ch == ord('*'):
                for d in view:
                    selected.add(d['_idx'])
            elif ch == ord('/'):  # search
                curses.echo()
                safe_addnstr(stdscr, max_y - 1, 0, 'Search: '.ljust(max_x), max_x, curses.A_REVERSE)
                q = stdscr.getstr(max_y - 1, len('Search: ')).decode()
                curses.noecho()
                if q:
                    for i, d in enumerate(view):
                        if q.lower() in (d['name'] + ' ' + d['model']).lower():
                            pos = i
                            break
            elif ch == ord('f'):
                curses.echo()
                safe_addnstr(stdscr, max_y - 1, 0, 'Filter: '.ljust(max_x), max_x, curses.A_REVERSE)
                filter_text = stdscr.getstr(max_y - 1, len('Filter: ')).decode()
                curses.noecho()
                view = apply_view()
                pos = 0
                top = 0
            elif ch == ord('s'):
                sort_idx = (sort_idx + 1) % len(sort_cycle)
                view = apply_view()
                pos = 0
                top = 0
            elif ch == ord('r'):
                reverse = not reverse
                view = apply_view()
            elif ch in (10, curses.KEY_ENTER):
                show_detail(stdscr, view[pos])
            elif ch in (ord('h'), ord('?')):
                show_help(stdscr)
            elif ch == 19:  # Ctrl-S
                break
            elif ch in (ord('q'), 3):
                selected.clear()
                break
            if pos < top:
                top = pos
            elif pos >= top + max_y - 2:
                top = pos - (max_y - 3)
        return [devs[i] for i in selected]

    return curses.wrapper(run)


def main():
    parser = argparse.ArgumentParser(description='Display information about block devices.')
    fmt = parser.add_mutually_exclusive_group()
    fmt.add_argument('--json', action='store_true', help='Output in JSON format')
    fmt.add_argument('--yaml', action='store_true', help='Output in YAML format')
    fmt.add_argument('--tsv', action='store_true', help='Output in TSV format')
    parser.add_argument('--type', help='Filter by transport type (e.g. nvme, sata)')
    parser.add_argument('--name', help='Filter by device name glob pattern')
    parser.add_argument('--node', type=int, help='Filter by NUMA node')
    parser.add_argument('--size-min', help='Minimum device size (e.g. 1G)')
    parser.add_argument('--size-max', help='Maximum device size (e.g. 10T)')
    parser.add_argument('--sort', choices=['name', 'size', 'vendor', 'numa'], help='Sort output by field')
    parser.add_argument('--reverse', action='store_true', help='Reverse sort order')
    parser.add_argument('--tui', '--interactive', dest='interactive', action='store_true',
                        help='Interactive TUI selection mode')
    parser.add_argument('--output', help='Write selected devices to file')
    unit = parser.add_mutually_exclusive_group()
    unit.add_argument('--si', action='store_true', help='Use 1000-based units')
    unit.add_argument('--iec', action='store_true', help='Use 1024-based units (default)')
    args = parser.parse_args()

    try:
        devs = collect_devices()
    except SystemExit:
        raise
    except Exception as e:
        print(f"Error collecting device data: {e}", file=sys.stderr)
        sys.exit(2)

    if args.size_min is not None:
        try:
            args.size_min = parse_size(args.size_min)
        except ValueError as e:
            print(str(e), file=sys.stderr)
            sys.exit(2)
    if args.size_max is not None:
        try:
            args.size_max = parse_size(args.size_max)
        except ValueError as e:
            print(str(e), file=sys.stderr)
            sys.exit(2)

    devs = apply_filters(devs, args)
    if not args.interactive:
        sort_devices(devs, args)

    si = args.si
    if args.interactive:
        selected = interactive_mode(devs, si)
        names = [d['name'] for d in selected]
        if args.yaml:
            try:
                import yaml
            except ModuleNotFoundError:
                print('YAML output requires PyYAML', file=sys.stderr)
                sys.exit(2)
            out_data = yaml.safe_dump(names, sort_keys=False)
        elif args.tsv:
            out_data = '\n'.join(names) + ('\n' if names else '')
        else:
            out_data = json.dumps(names)
        if args.output:
            with open(args.output, 'w') as f:
                f.write(out_data if out_data.endswith('\n') else out_data + '\n')
        else:
            sys.stdout.write(out_data if out_data.endswith('\n') else out_data + '\n')
        sys.exit(0 if names else 1)
    else:
        if args.json:
            output_json(devs, si)
        elif args.yaml:
            output_yaml(devs, si)
        elif args.tsv:
            output_tsv(devs, si)
        else:
            output_table(devs, si)


if __name__ == '__main__':
    main()
